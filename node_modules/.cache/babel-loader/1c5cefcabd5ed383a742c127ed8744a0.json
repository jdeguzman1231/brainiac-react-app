{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\n\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n\n  callTargets(targets, methodName, ...args) {\n    return targets.map(target => {\n      const method = target[methodName];\n\n      if (method && typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  invokeHookAsync(methodName, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield Promise.all(this.callTargets(this.targets, methodName, ...args));\n    });\n  }\n\n  invokeHookSync(methodName, ...args) {\n    return this.callTargets(this.targets, methodName, ...args);\n  }\n\n  reverseInvokeHookSync(methodName, ...args) {\n    return this.callTargets(this.targets.reverse(), methodName, ...args);\n  }\n\n  invokeHooksUntilNonNull(methodName, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const target of this.targets) {\n        const method = target[methodName];\n\n        if (!(method && typeof method === 'function')) {\n          continue;\n        }\n\n        const value = yield method.apply(target, args);\n\n        if (value !== null) {\n          return value;\n        }\n      }\n\n      return null;\n    });\n  }\n\n  invokeDidStartHook(methodName, ...args) {\n    const didEndHooks = [];\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n\n      if (method && typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n\n    return (...args) => {\n      didEndHooks.reverse();\n\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n\n}\n\nexports.Dispatcher = Dispatcher;","map":{"version":3,"sources":["../../src/utils/dispatcher.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,MAAa,UAAb,CAAuB;AACrB,EAAA,WAAA,CAAsB,OAAtB,EAAkC;AAAZ,SAAA,OAAA,GAAA,OAAA;AAAgB;;AAE9B,EAAA,WAAW,CACjB,OADiB,EAEjB,UAFiB,EAGjB,GAAG,IAHc,EAGY;AAE7B,WAAO,OAAO,CAAC,GAAR,CAAY,MAAM,IAAG;AAC1B,YAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,UAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,UAAhC,EAA4C;AAC1C,eAAO,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAAP;AACD;AACF,KALM,CAAP;AAMD;;AAEY,EAAA,eAAe,CAC1B,UAD0B,EAE1B,GAAG,IAFuB,EAEG;;AAE7B,aAAO,MAAM,OAAO,CAAC,GAAR,CACX,KAAK,WAAL,CAAiB,KAAK,OAAtB,EAA+B,UAA/B,EAA2C,GAAG,IAA9C,CADW,CAAb;AAED,K;AAAA;;AAEM,EAAA,cAAc,CACnB,UADmB,EAEnB,GAAG,IAFgB,EAEU;AAE7B,WAAO,KAAK,WAAL,CAAiB,KAAK,OAAtB,EAA+B,UAA/B,EAA2C,GAAG,IAA9C,CAAP;AACD;;AAEM,EAAA,qBAAqB,CAC1B,UAD0B,EAE1B,GAAG,IAFuB,EAEG;AAE7B,WAAO,KAAK,WAAL,CAAiB,KAAK,OAAL,CAAa,OAAb,EAAjB,EAAyC,UAAzC,EAAqD,GAAG,IAAxD,CAAP;AACD;;AAEY,EAAA,uBAAuB,CAClC,UADkC,EAElC,GAAG,IAF+B,EAEL;;AAE7B,WAAK,MAAM,MAAX,IAAqB,KAAK,OAA1B,EAAmC;AACjC,cAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,YAAI,EAAE,MAAM,IAAI,OAAO,MAAP,KAAkB,UAA9B,CAAJ,EAA+C;AAC7C;AACD;;AACD,cAAM,KAAK,GAAG,MAAM,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAApB;;AACA,YAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAO,KAAP;AACD;AACF;;AACD,aAAO,IAAP;AACD,K;AAAA;;AAEM,EAAA,kBAAkB,CAIvB,UAJuB,EAKvB,GAAG,IALoB,EAKM;AAE7B,UAAM,WAAW,GAA+B,EAAhD;;AAEA,SAAK,MAAM,MAAX,IAAqB,KAAK,OAA1B,EAAmC;AACjC,YAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,UAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,UAAhC,EAA4C;AAC1C,cAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAAnB;;AACA,YAAI,UAAJ,EAAgB;AACd,UAAA,WAAW,CAAC,IAAZ,CAAiB,UAAjB;AACD;AACF;AACF;;AAED,WAAO,CAAC,GAAG,IAAJ,KAA0B;AAC/B,MAAA,WAAW,CAAC,OAAZ;;AAEA,WAAK,MAAM,UAAX,IAAyB,WAAzB,EAAsC;AACpC,QAAA,UAAU,CAAC,GAAG,IAAJ,CAAV;AACD;AACF,KAND;AAOD;;AAjFoB;;AAAvB,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dispatcher = void 0;\nclass Dispatcher {\n    constructor(targets) {\n        this.targets = targets;\n    }\n    callTargets(targets, methodName, ...args) {\n        return targets.map(target => {\n            const method = target[methodName];\n            if (method && typeof method === 'function') {\n                return method.apply(target, args);\n            }\n        });\n    }\n    invokeHookAsync(methodName, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield Promise.all(this.callTargets(this.targets, methodName, ...args));\n        });\n    }\n    invokeHookSync(methodName, ...args) {\n        return this.callTargets(this.targets, methodName, ...args);\n    }\n    reverseInvokeHookSync(methodName, ...args) {\n        return this.callTargets(this.targets.reverse(), methodName, ...args);\n    }\n    invokeHooksUntilNonNull(methodName, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const target of this.targets) {\n                const method = target[methodName];\n                if (!(method && typeof method === 'function')) {\n                    continue;\n                }\n                const value = yield method.apply(target, args);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        });\n    }\n    invokeDidStartHook(methodName, ...args) {\n        const didEndHooks = [];\n        for (const target of this.targets) {\n            const method = target[methodName];\n            if (method && typeof method === 'function') {\n                const didEndHook = method.apply(target, args);\n                if (didEndHook) {\n                    didEndHooks.push(didEndHook);\n                }\n            }\n        }\n        return (...args) => {\n            didEndHooks.reverse();\n            for (const didEndHook of didEndHooks) {\n                didEndHook(...args);\n            }\n        };\n    }\n}\nexports.Dispatcher = Dispatcher;\n//# sourceMappingURL=dispatcher.js.map"]},"metadata":{},"sourceType":"script"}