{"ast":null,"code":"import util from 'util';\nimport Busboy from 'busboy';\nimport { WriteStream } from 'fs-capacitor';\nimport createError from 'http-errors';\nimport objectPath from 'object-path';\nimport { SPEC_URL } from './constants';\nimport { ignoreStream } from './ignoreStream';\nimport { isEnumerableObject } from './isEnumerableObject';\n\nclass Upload {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = file => {\n        this.file = file;\n        resolve(file);\n      };\n\n      this.reject = reject;\n    });\n    this.promise.catch(() => {});\n  }\n\n}\n\nexport const processRequest = (request, response, {\n  maxFieldSize = 1000000,\n  maxFileSize = Infinity,\n  maxFiles = Infinity\n} = {}) => new Promise((resolve, reject) => {\n  let released;\n  let exitError;\n  let currentStream;\n  let operations;\n  let operationsPath;\n  let map;\n  const parser = new Busboy({\n    headers: request.headers,\n    limits: {\n      fieldSize: maxFieldSize,\n      fields: 2,\n      fileSize: maxFileSize,\n      files: maxFiles\n    }\n  });\n\n  const exit = error => {\n    if (exitError) return;\n    exitError = error;\n    reject(exitError);\n    parser.destroy();\n    if (currentStream) currentStream.destroy(exitError);\n    if (map) for (const upload of map.values()) if (!upload.file) upload.reject(exitError);\n    request.unpipe(parser);\n    setImmediate(() => {\n      request.resume();\n    });\n  };\n\n  const release = () => {\n    // istanbul ignore next\n    if (released) return;\n    released = true;\n    if (map) for (const upload of map.values()) if (upload.file) upload.file.capacitor.destroy();\n  };\n\n  const abort = () => {\n    exit(createError(499, 'Request disconnected during file upload stream parsing.'));\n  };\n\n  parser.on('field', (fieldName, value, fieldNameTruncated, valueTruncated) => {\n    if (exitError) return;\n    if (valueTruncated) return exit(createError(413, `The ‘${fieldName}’ multipart field value exceeds the ${maxFieldSize} byte size limit.`));\n\n    switch (fieldName) {\n      case 'operations':\n        try {\n          operations = JSON.parse(value);\n        } catch (error) {\n          return exit(createError(400, `Invalid JSON in the ‘operations’ multipart field (${SPEC_URL}).`));\n        }\n\n        if (!isEnumerableObject(operations) && !Array.isArray(operations)) return exit(createError(400, `Invalid type for the ‘operations’ multipart field (${SPEC_URL}).`));\n        operationsPath = objectPath(operations);\n        break;\n\n      case 'map':\n        {\n          if (!operations) return exit(createError(400, `Misordered multipart fields; ‘map’ should follow ‘operations’ (${SPEC_URL}).`));\n          let parsedMap;\n\n          try {\n            parsedMap = JSON.parse(value);\n          } catch (error) {\n            return exit(createError(400, `Invalid JSON in the ‘map’ multipart field (${SPEC_URL}).`));\n          }\n\n          if (!isEnumerableObject(parsedMap)) return exit(createError(400, `Invalid type for the ‘map’ multipart field (${SPEC_URL}).`));\n          const mapEntries = Object.entries(parsedMap);\n          if (mapEntries.length > maxFiles) return exit(createError(413, `${maxFiles} max file uploads exceeded.`));\n          map = new Map();\n\n          for (const [fieldName, paths] of mapEntries) {\n            if (!Array.isArray(paths)) return exit(createError(400, `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array (${SPEC_URL}).`));\n            map.set(fieldName, new Upload());\n\n            for (const [index, path] of paths.entries()) {\n              if (typeof path !== 'string') return exit(createError(400, `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value (${SPEC_URL}).`));\n\n              try {\n                operationsPath.set(path, map.get(fieldName).promise);\n              } catch (error) {\n                return exit(createError(400, `Invalid object path for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value ‘${path}’ (${SPEC_URL}).`));\n              }\n            }\n          }\n\n          resolve(operations);\n        }\n    }\n  });\n  parser.on('file', (fieldName, stream, filename, encoding, mimetype) => {\n    if (exitError) {\n      ignoreStream(stream);\n      return;\n    }\n\n    if (!map) {\n      ignoreStream(stream);\n      return exit(createError(400, `Misordered multipart fields; files should follow ‘map’ (${SPEC_URL}).`));\n    }\n\n    currentStream = stream;\n    stream.on('end', () => {\n      currentStream = null;\n    });\n    const upload = map.get(fieldName);\n\n    if (!upload) {\n      ignoreStream(stream);\n      return;\n    }\n\n    const capacitor = new WriteStream();\n    capacitor.on('error', () => {\n      stream.unpipe();\n      stream.resume();\n    });\n    stream.on('limit', () => {\n      stream.unpipe();\n      capacitor.destroy(createError(413, `File truncated as it exceeds the ${maxFileSize} byte size limit.`));\n    });\n    stream.on('error', error => {\n      stream.unpipe(); // istanbul ignore next\n\n      capacitor.destroy(exitError || error);\n    });\n    stream.pipe(capacitor);\n    const file = {\n      filename,\n      mimetype,\n      encoding,\n\n      createReadStream() {\n        const error = capacitor.error || (released ? exitError : null);\n        if (error) throw error;\n        return capacitor.createReadStream();\n      }\n\n    };\n    let capacitorStream;\n    Object.defineProperty(file, 'stream', {\n      get: util.deprecate(function () {\n        if (!capacitorStream) capacitorStream = this.createReadStream();\n        return capacitorStream;\n      }, 'File upload property ‘stream’ is deprecated. Use ‘createReadStream()’ instead.')\n    });\n    Object.defineProperty(file, 'capacitor', {\n      value: capacitor\n    });\n    upload.resolve(file);\n  });\n  parser.once('filesLimit', () => exit(createError(413, `${maxFiles} max file uploads exceeded.`)));\n  parser.once('finish', () => {\n    request.unpipe(parser);\n    request.resume();\n    if (!operations) return exit(createError(400, `Missing multipart field ‘operations’ (${SPEC_URL}).`));\n    if (!map) return exit(createError(400, `Missing multipart field ‘map’ (${SPEC_URL}).`));\n\n    for (const upload of map.values()) if (!upload.file) upload.reject(createError(400, 'File missing in the request.'));\n  });\n  parser.once('error', exit);\n  response.once('finish', release);\n  response.once('close', release);\n  request.once('close', abort);\n  request.once('end', () => {\n    request.removeListener('close', abort);\n  });\n  request.pipe(parser);\n});","map":{"version":3,"sources":["/Users/josephdeguzman/Documents/CSE/brainiac-app/node_modules/@apollographql/graphql-upload-8-fork/lib/processRequest.mjs"],"names":["util","Busboy","WriteStream","createError","objectPath","SPEC_URL","ignoreStream","isEnumerableObject","Upload","constructor","promise","Promise","resolve","reject","file","catch","processRequest","request","response","maxFieldSize","maxFileSize","Infinity","maxFiles","released","exitError","currentStream","operations","operationsPath","map","parser","headers","limits","fieldSize","fields","fileSize","files","exit","error","destroy","upload","values","unpipe","setImmediate","resume","release","capacitor","abort","on","fieldName","value","fieldNameTruncated","valueTruncated","JSON","parse","Array","isArray","parsedMap","mapEntries","Object","entries","length","Map","paths","set","index","path","get","stream","filename","encoding","mimetype","pipe","createReadStream","capacitorStream","defineProperty","deprecate","once","removeListener"],"mappings":"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","sourcesContent":["import util from 'util'\nimport Busboy from 'busboy'\nimport { WriteStream } from 'fs-capacitor'\nimport createError from 'http-errors'\nimport objectPath from 'object-path'\nimport { SPEC_URL } from './constants'\nimport { ignoreStream } from './ignoreStream'\nimport { isEnumerableObject } from './isEnumerableObject'\n\nclass Upload {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = file => {\n        this.file = file\n        resolve(file)\n      }\n\n      this.reject = reject\n    })\n    this.promise.catch(() => {})\n  }\n}\n\nexport const processRequest = (\n  request,\n  response,\n  { maxFieldSize = 1000000, maxFileSize = Infinity, maxFiles = Infinity } = {}\n) =>\n  new Promise((resolve, reject) => {\n    let released\n    let exitError\n    let currentStream\n    let operations\n    let operationsPath\n    let map\n    const parser = new Busboy({\n      headers: request.headers,\n      limits: {\n        fieldSize: maxFieldSize,\n        fields: 2,\n        fileSize: maxFileSize,\n        files: maxFiles\n      }\n    })\n\n    const exit = error => {\n      if (exitError) return\n      exitError = error\n      reject(exitError)\n      parser.destroy()\n      if (currentStream) currentStream.destroy(exitError)\n      if (map)\n        for (const upload of map.values())\n          if (!upload.file) upload.reject(exitError)\n      request.unpipe(parser)\n      setImmediate(() => {\n        request.resume()\n      })\n    }\n\n    const release = () => {\n      // istanbul ignore next\n      if (released) return\n      released = true\n      if (map)\n        for (const upload of map.values())\n          if (upload.file) upload.file.capacitor.destroy()\n    }\n\n    const abort = () => {\n      exit(\n        createError(\n          499,\n          'Request disconnected during file upload stream parsing.'\n        )\n      )\n    }\n\n    parser.on(\n      'field',\n      (fieldName, value, fieldNameTruncated, valueTruncated) => {\n        if (exitError) return\n        if (valueTruncated)\n          return exit(\n            createError(\n              413,\n              `The ‘${fieldName}’ multipart field value exceeds the ${maxFieldSize} byte size limit.`\n            )\n          )\n\n        switch (fieldName) {\n          case 'operations':\n            try {\n              operations = JSON.parse(value)\n            } catch (error) {\n              return exit(\n                createError(\n                  400,\n                  `Invalid JSON in the ‘operations’ multipart field (${SPEC_URL}).`\n                )\n              )\n            }\n\n            if (!isEnumerableObject(operations) && !Array.isArray(operations))\n              return exit(\n                createError(\n                  400,\n                  `Invalid type for the ‘operations’ multipart field (${SPEC_URL}).`\n                )\n              )\n            operationsPath = objectPath(operations)\n            break\n\n          case 'map': {\n            if (!operations)\n              return exit(\n                createError(\n                  400,\n                  `Misordered multipart fields; ‘map’ should follow ‘operations’ (${SPEC_URL}).`\n                )\n              )\n            let parsedMap\n\n            try {\n              parsedMap = JSON.parse(value)\n            } catch (error) {\n              return exit(\n                createError(\n                  400,\n                  `Invalid JSON in the ‘map’ multipart field (${SPEC_URL}).`\n                )\n              )\n            }\n\n            if (!isEnumerableObject(parsedMap))\n              return exit(\n                createError(\n                  400,\n                  `Invalid type for the ‘map’ multipart field (${SPEC_URL}).`\n                )\n              )\n            const mapEntries = Object.entries(parsedMap)\n            if (mapEntries.length > maxFiles)\n              return exit(\n                createError(413, `${maxFiles} max file uploads exceeded.`)\n              )\n            map = new Map()\n\n            for (const [fieldName, paths] of mapEntries) {\n              if (!Array.isArray(paths))\n                return exit(\n                  createError(\n                    400,\n                    `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array (${SPEC_URL}).`\n                  )\n                )\n              map.set(fieldName, new Upload())\n\n              for (const [index, path] of paths.entries()) {\n                if (typeof path !== 'string')\n                  return exit(\n                    createError(\n                      400,\n                      `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value (${SPEC_URL}).`\n                    )\n                  )\n\n                try {\n                  operationsPath.set(path, map.get(fieldName).promise)\n                } catch (error) {\n                  return exit(\n                    createError(\n                      400,\n                      `Invalid object path for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value ‘${path}’ (${SPEC_URL}).`\n                    )\n                  )\n                }\n              }\n            }\n\n            resolve(operations)\n          }\n        }\n      }\n    )\n    parser.on('file', (fieldName, stream, filename, encoding, mimetype) => {\n      if (exitError) {\n        ignoreStream(stream)\n        return\n      }\n\n      if (!map) {\n        ignoreStream(stream)\n        return exit(\n          createError(\n            400,\n            `Misordered multipart fields; files should follow ‘map’ (${SPEC_URL}).`\n          )\n        )\n      }\n\n      currentStream = stream\n      stream.on('end', () => {\n        currentStream = null\n      })\n      const upload = map.get(fieldName)\n\n      if (!upload) {\n        ignoreStream(stream)\n        return\n      }\n\n      const capacitor = new WriteStream()\n      capacitor.on('error', () => {\n        stream.unpipe()\n        stream.resume()\n      })\n      stream.on('limit', () => {\n        stream.unpipe()\n        capacitor.destroy(\n          createError(\n            413,\n            `File truncated as it exceeds the ${maxFileSize} byte size limit.`\n          )\n        )\n      })\n      stream.on('error', error => {\n        stream.unpipe() // istanbul ignore next\n\n        capacitor.destroy(exitError || error)\n      })\n      stream.pipe(capacitor)\n      const file = {\n        filename,\n        mimetype,\n        encoding,\n\n        createReadStream() {\n          const error = capacitor.error || (released ? exitError : null)\n          if (error) throw error\n          return capacitor.createReadStream()\n        }\n      }\n      let capacitorStream\n      Object.defineProperty(file, 'stream', {\n        get: util.deprecate(function() {\n          if (!capacitorStream) capacitorStream = this.createReadStream()\n          return capacitorStream\n        }, 'File upload property ‘stream’ is deprecated. Use ‘createReadStream()’ instead.')\n      })\n      Object.defineProperty(file, 'capacitor', {\n        value: capacitor\n      })\n      upload.resolve(file)\n    })\n    parser.once('filesLimit', () =>\n      exit(createError(413, `${maxFiles} max file uploads exceeded.`))\n    )\n    parser.once('finish', () => {\n      request.unpipe(parser)\n      request.resume()\n      if (!operations)\n        return exit(\n          createError(\n            400,\n            `Missing multipart field ‘operations’ (${SPEC_URL}).`\n          )\n        )\n      if (!map)\n        return exit(\n          createError(400, `Missing multipart field ‘map’ (${SPEC_URL}).`)\n        )\n\n      for (const upload of map.values())\n        if (!upload.file)\n          upload.reject(createError(400, 'File missing in the request.'))\n    })\n    parser.once('error', exit)\n    response.once('finish', release)\n    response.once('close', release)\n    request.once('close', abort)\n    request.once('end', () => {\n      request.removeListener('close', abort)\n    })\n    request.pipe(parser)\n  })\n"]},"metadata":{},"sourceType":"module"}